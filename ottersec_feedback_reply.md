1. **In consume_prompt, the relationship between the Agent and the Enclave is not verified, so an attacker could use a signature generated by a fake Enclave to win**


If attacker uses a signature generated by a fake enclave, that signature will have incorrect enclave public key, and the [verify_signature](https://github.com/sui-sentinel/contracts/blob/master/enclave/sources/enclave.move#L106) method will fail.
Also as mentioned in [Nautilus design Sui documentation](https://docs.sui.io/concepts/cryptography/nautilus/nautilus-design), every enclave have a unique public key and any signature generated from enclave takes this public key as a param so if user uses fake enclave, singature will not match.

this is also secured since we are registering the enclave with our package ID during deployment. you can see deployment and register flow in scripts/deployment.sh and scripts/register_enclave.sh.


2.**Since agent_list in AgentRegistry is a vector<String>, an attacker can create a large number of agents and push the object size up to max_move_object_size**

This makes sense. perhaps to resolve this and #5, enforcing funding of at least 1 sui might be good idea.

3. **An attacker can call fund_agent with 0 SUI and block the creator from calling withdraw_from_agent**

Makes total sense, this method should only be callable by agent creator.

4. **The creator can delete the Enclave to avoid paying out the rewards accumulated on the Agent. Meanwhile, withdraw_from_agent is still callable even without an Enclave**

Agent Creator have no authority over the enclave and just to make it clear, there is a single enclave(AWS Nitro server) managed by the team and it can not be deleted by agent creators or users.

5. **If a user creates an agent and never call fund_agent, then last_funded_timestamp stays at 0. but if someone submits a request for attack, the creator can steal that reward through withdraw_from_agent**

Perhaps this is an issue but here I'm leaning on users(attackers) common sense where they don't attack the agent if they don't see any incentive(prize pool) for the respective agent.


6. **Since multiple enclave's config can be created by a module, its possible to create an enclave using one, and then use a different config to destroy it (if the later has a bigger version)**.
7. **Outdated enclaves can still be used**

For both #6 and #7, there seems to be an architectural misunderstanding since there is a single enclave being used throughout the platform and creating a new agent doesn't mean creating new enclave. that obviously will not be cost effective since creating an enclave is a high cost operation.


8. **There are no timestamp checks for signatures, so an user could keep the signature and wait until the agent get more funds to execute the attack. We recommend adding an expiration for the signatures**

Yes this makes sense. we can add a check in consume_prompt to check if timestamp_ms is not older than 5 minutes.


9. **Requiring a one time witness for enclave::new_cap would make it safer as it would be impossible for others to create caps (and therefore configs and enclaves) using the same type as a module**
Still digging deeper into this but yes I agree using OTW here is more secure.



