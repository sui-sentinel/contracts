Thank you so much @@sangsoo_osec for the detailed feedback, this was really really helpful in improving the contracts for security and efficiency. While we are going through the Enclave security issue that presumably allows anyone to deploy fake enclave and exploit contracts, we have addressed all following issues.

Issues

1. RegisterAgentResponse should also include the creator address, otherwise someone may frontrun a register_agent call, copy all the fields basically to steal the agent_id, and then update the prompt and the cost per message as they wish
 - Fixed, Now creator address is part of RegisterAgentResponse. 
2. update_agent_prompt should be timelocked, otherwise a defender could exploit prompt updates to steal value from attackers.
 - Fixed, `update_agent_prompt` is now timelocked to 180 minutes post register_agent.
3. The prompt arg in consume_prompt is not validated, so an attacker could pass anything as prompt and would result in an inaccurate event
 - Fixed, Now signature includes prompt blake2b256 hash, in `consume_prompt`, this hash is recomputed again and is parameter for signature verification. 


Suggestions

1. We suggest destroying the Attack Object in consume_prompt to receive a storage rebate, since it no longer needs to exist after it has been consumed
- This was really really good sugestion and reduces the gas fees. Now I'm destroying Attack object in `consume_prompt`
2. We suggest adding length validation for the prompt in consume_prompt, and for the system_prompt in register_agent and update_agent_prompt
 - Good Suggestion. Added length validation for prompt and system_prompt.
3. withdraw_from_agent could just assert is_withdrawal_unlocked instead of duplicating that code
 - Done. 

Questions

1. Why is the agent_id required as a separate argument in request_attack and consume_prompt?
  - Actually we didn't need it as we are passing Agent object itself. I've removed it from both methods 
2. Wouldn't it make more sense to just store the creator_fee and the protocol_fee and send the rest to the agent rather than storing all 3 and including the reminder calcs?
  - Yes absolutely, very good suggestion, I've implemented the changes. 
3. Who pays for the cost of using the agent model? Is there a guideline for how the defender should set the fee_per_message? If a creator set the fee_per_message to 0 and just fund the reward pool, then request_attack wouldn’t send any fees to the Sentinel team.
 - Sui sentinel will bear the cost of model as we don't want dependers to pass their api key for vaious models. there will be minimum fee_per_message enforced from TEE side as the first call for register_agent flow happens on TEE side.
4. Is there an invariant that success == true if and only if score > 95 here?
  - removed the score > 95 check.  


**Fixed Issues from Previous feedback**

1. Since agent_list in AgentRegistry is a vector<String>, an attacker can create a large number of agents and push the object size up to max_move_object_size
 - agent_registry struct, `agent_list` vector is removed as we are already adding the agent in a registry table, we don;t really need it.
2. An attacker can call fund_agent with 0 SUI and block the creator from calling withdraw_from_agent
 - Fixed, now only agent_creator can call this method.


# Previous feedback


Hi team, we've finished our review. Some findings from our side:

Issues
1. In consume_prompt, the relationship between the Agent and the Enclave is not verified, so an attacker could use a signature generated by a fake Enclave to win
2. Since agent_list in AgentRegistry is a vector<String>, an attacker can create a large number of agents and push the object size up to max_move_object_size
3. An attacker can call fund_agent with 0 SUI and block the creator from calling withdraw_from_agent
4. The creator can delete the Enclave to avoid paying out the rewards accumulated on the Agent. Meanwhile, withdraw_from_agent is still callable even without an Enclave
5. If a user creates an agent and never call fund_agent, then last_funded_timestamp stays at 0. but if someone submits a request for attack, the creator can steal that reward through withdraw_from_agent
6. Since multiple enclave's config can be created by a module, its possible to create an enclave using one, and then use a different config to destroy it (if the later has a bigger version).
7. Outdated enclaves can still be used
8. There are no timestamp checks for signatures, so an user could keep the signature and wait until the agent get more funds to execute the attack. We recommend adding an expiration for the signatures
9. Requiring a one time witness for enclave::new_cap would make it safer as it would be impossible for others to create caps (and therefore configs and enclaves) using the same type as a module

Suggestions
1. Since the epoch length is 1 day, sui random module can be used here
2. AgentCap can be used instead of Attack.admin
3. We suggest replacing 95 here with a configurable value
4. For PromptConsumed, it’d be better to use the success value that’s passed in as an argument here
5. This check looks redundant, since Attacker is an owned object
6. Setter function that emit events such as sentinel::update_protocol_wallet could check if the new value is different from old one for avoiding emitting unnecessary events
7. We think enclave::deploy_old_enclave_by_owner was supposed to be called destroy_old_enclave_by_owner. Also, this function destroys the enclave without checking its version, so maybe it should be called destroy_enclave_by_owner

Questions
1. When a creator calls update_agent_prompt, are we assuming that the enclave’s PCR also changes, or does it stay the same?




## OtterSec



